# 第一部分 走进Java
# 第二部分 自动内存管理
## 第二章 Java内存区域与内存溢出异常
### 2.1 运行时数据区
#### 2.1.1 程序计数器
    特点：
    1、内存空间较小，当前线程所执行的字节码的行号指示器。
    2、分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
    3、每条线程均存在一个独立的程序计数器，线程私有。
    4、如果线程执行的是native方法，则这个计数器值为空（undefined）
    5、此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域
#### 2.1.2 Java虚拟机栈
    特点：
    1、线程私有，生命周期与线程相同
    2、每个方法被执行的时候，JVM会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
    3、此内存区域规定了两类异常状况：
        1> StackOverFlowError：线程请求的栈深度大于虚拟机所允许的深度
        2> OutOfMemoryError：栈容量动态扩展到无法申请到足够的内存会抛出此异常
    注意：
    HotSpot虚拟机的栈容量是不可以动态扩展的
---
**局部变量表**

    1、存放了编译期可知的基本数据类型、对象引用和返回地址
    2、这些数据类型存放在局部变量槽（Slot）中，其中64位长度long和double会占用两个槽，其余数据类型占用1个。
    3、内存空间在编译期完成分配，进入方法钱就完全确定了
#### 2.1.3 本地方法栈
    特点：
    1、与虚拟机栈类似，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务
    2、也会抛出OOM和stackoverflow
    3、对本地方法栈中方法使用的语言、使用方式与数据结构没有任何强制规定
#### 2.1.4 Java堆
    特点：
    1、虚拟机管理内存中最大的一块
    2、线程共享，虚拟机启动时创建，唯一目的就是存放对象实例（几乎所有）
    3、存在多个线程私有的分配缓冲区（TLAB），以提升对象分配时的效率
    4、目的更好的回收内存或更快的分配内存
    5、可以处于物理上不连续的区域，但逻辑上应该连续
    6、可动态扩展（-Xmx与-Xms）
    7、OOM
#### 2.1.5 方法区
    特点：
    1、线程共享，用于存储已加载的类型信息、常量、静态变量、即时编译后的代码缓存等数据
    2、永久代剩余内容迁移到元空间，之前使用永久代来实现方法区，会容易导致出现内存溢出的问题
#### 2.1.6 运行时常量池
    特点：
    1、方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。
    2、具备动态性，运行期间也可以将新的常量放入池中，例如String类的intern()方法
    3、也会出现OOM异常
#### 2.1.7 直接内存
    特点：
    1、不属于运行时数据区、已不是jvm规范定义的内存区域
### 2.2 HotSpot对象探秘
####2.2.1 对象的创建
####2.2.2 对象的内存布局
> * 对象头：
> * 实例数据：
> * 对其填充：
####2.2.3 对象的访问定位
![1](src\main\resource\1.png "1")
###2.3 实战
####2.3.1 Java堆溢出
## 三、jvm参数
    1、-XX: MaxMetaspaceSize: 设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小
    2、-XX: MetaspaceSize： 指定元空间的初始空间大小，以字节为单位看，达到该值会触发垃圾收集进行类型卸载，
    同时会自动调整该值，释放了大量空间就减小，否则就增加，但是不超过Max
    3、-XX: MinMetaspaceFreeRatio: 作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集频率
    4、-XX: MaxDirecMemorySize参数：指定直接内存的大小，默认与堆（Xmx）最大值一致。
    
